// Code generated by protoc-gen-go. DO NOT EDIT.
// source: shell.proto

/*
Package shell is a generated protocol buffer package.

It is generated from these files:
	shell.proto

It has these top-level messages:
	Ping
	Command
	CommandOutput
	CommandExit
	TimeRequest
	TimeResponse
	PingRequest
	PingResponse
	ExecRequest
	ExecResponse
	FollowRequest
	FollowResponse
*/
package shell

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CommandOutput_Source int32

const (
	CommandOutput_DAEMON CommandOutput_Source = 0
	CommandOutput_STDOUT CommandOutput_Source = 1
	CommandOutput_STDERR CommandOutput_Source = 2
)

var CommandOutput_Source_name = map[int32]string{
	0: "DAEMON",
	1: "STDOUT",
	2: "STDERR",
}
var CommandOutput_Source_value = map[string]int32{
	"DAEMON": 0,
	"STDOUT": 1,
	"STDERR": 2,
}

func (x CommandOutput_Source) String() string {
	return proto.EnumName(CommandOutput_Source_name, int32(x))
}
func (CommandOutput_Source) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

type Ping struct {
	Time *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=time" json:"time,omitempty"`
}

func (m *Ping) Reset()                    { *m = Ping{} }
func (m *Ping) String() string            { return proto.CompactTextString(m) }
func (*Ping) ProtoMessage()               {}
func (*Ping) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Ping) GetTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

type Command struct {
	Id      string   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Name    string   `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Args    []string `protobuf:"bytes,3,rep,name=args" json:"args,omitempty"`
	Timeout int64    `protobuf:"varint,4,opt,name=timeout" json:"timeout,omitempty"`
}

func (m *Command) Reset()                    { *m = Command{} }
func (m *Command) String() string            { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()               {}
func (*Command) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Command) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Command) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Command) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *Command) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type CommandOutput struct {
	CommandId string                     `protobuf:"bytes,1,opt,name=command_id,json=commandId" json:"command_id,omitempty"`
	ShellId   string                     `protobuf:"bytes,2,opt,name=shell_id,json=shellId" json:"shell_id,omitempty"`
	Time      *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=time" json:"time,omitempty"`
	Source    CommandOutput_Source       `protobuf:"varint,4,opt,name=source,enum=shell.CommandOutput_Source" json:"source,omitempty"`
	Line      string                     `protobuf:"bytes,5,opt,name=line" json:"line,omitempty"`
}

func (m *CommandOutput) Reset()                    { *m = CommandOutput{} }
func (m *CommandOutput) String() string            { return proto.CompactTextString(m) }
func (*CommandOutput) ProtoMessage()               {}
func (*CommandOutput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CommandOutput) GetCommandId() string {
	if m != nil {
		return m.CommandId
	}
	return ""
}

func (m *CommandOutput) GetShellId() string {
	if m != nil {
		return m.ShellId
	}
	return ""
}

func (m *CommandOutput) GetTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *CommandOutput) GetSource() CommandOutput_Source {
	if m != nil {
		return m.Source
	}
	return CommandOutput_DAEMON
}

func (m *CommandOutput) GetLine() string {
	if m != nil {
		return m.Line
	}
	return ""
}

type CommandExit struct {
	CommandId string                     `protobuf:"bytes,1,opt,name=command_id,json=commandId" json:"command_id,omitempty"`
	ShellId   string                     `protobuf:"bytes,2,opt,name=shell_id,json=shellId" json:"shell_id,omitempty"`
	Time      *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=time" json:"time,omitempty"`
	Code      int64                      `protobuf:"varint,4,opt,name=code" json:"code,omitempty"`
}

func (m *CommandExit) Reset()                    { *m = CommandExit{} }
func (m *CommandExit) String() string            { return proto.CompactTextString(m) }
func (*CommandExit) ProtoMessage()               {}
func (*CommandExit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CommandExit) GetCommandId() string {
	if m != nil {
		return m.CommandId
	}
	return ""
}

func (m *CommandExit) GetShellId() string {
	if m != nil {
		return m.ShellId
	}
	return ""
}

func (m *CommandExit) GetTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *CommandExit) GetCode() int64 {
	if m != nil {
		return m.Code
	}
	return 0
}

type TimeRequest struct {
}

func (m *TimeRequest) Reset()                    { *m = TimeRequest{} }
func (m *TimeRequest) String() string            { return proto.CompactTextString(m) }
func (*TimeRequest) ProtoMessage()               {}
func (*TimeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type TimeResponse struct {
	Time *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=time" json:"time,omitempty"`
}

func (m *TimeResponse) Reset()                    { *m = TimeResponse{} }
func (m *TimeResponse) String() string            { return proto.CompactTextString(m) }
func (*TimeResponse) ProtoMessage()               {}
func (*TimeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *TimeResponse) GetTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

type PingRequest struct {
	Data *Ping `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *PingRequest) Reset()                    { *m = PingRequest{} }
func (m *PingRequest) String() string            { return proto.CompactTextString(m) }
func (*PingRequest) ProtoMessage()               {}
func (*PingRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PingRequest) GetData() *Ping {
	if m != nil {
		return m.Data
	}
	return nil
}

type PingResponse struct {
	Data *Ping `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *PingResponse) Reset()                    { *m = PingResponse{} }
func (m *PingResponse) String() string            { return proto.CompactTextString(m) }
func (*PingResponse) ProtoMessage()               {}
func (*PingResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *PingResponse) GetData() *Ping {
	if m != nil {
		return m.Data
	}
	return nil
}

type ExecRequest struct {
	Command *Command `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
}

func (m *ExecRequest) Reset()                    { *m = ExecRequest{} }
func (m *ExecRequest) String() string            { return proto.CompactTextString(m) }
func (*ExecRequest) ProtoMessage()               {}
func (*ExecRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ExecRequest) GetCommand() *Command {
	if m != nil {
		return m.Command
	}
	return nil
}

type ExecResponse struct {
	Output *CommandOutput `protobuf:"bytes,1,opt,name=output" json:"output,omitempty"`
}

func (m *ExecResponse) Reset()                    { *m = ExecResponse{} }
func (m *ExecResponse) String() string            { return proto.CompactTextString(m) }
func (*ExecResponse) ProtoMessage()               {}
func (*ExecResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ExecResponse) GetOutput() *CommandOutput {
	if m != nil {
		return m.Output
	}
	return nil
}

type FollowRequest struct {
	// Types that are valid to be assigned to Data:
	//	*FollowRequest_Output
	//	*FollowRequest_Exit
	Data isFollowRequest_Data `protobuf_oneof:"data"`
}

func (m *FollowRequest) Reset()                    { *m = FollowRequest{} }
func (m *FollowRequest) String() string            { return proto.CompactTextString(m) }
func (*FollowRequest) ProtoMessage()               {}
func (*FollowRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type isFollowRequest_Data interface {
	isFollowRequest_Data()
}

type FollowRequest_Output struct {
	Output *CommandOutput `protobuf:"bytes,1,opt,name=output,oneof"`
}
type FollowRequest_Exit struct {
	Exit *CommandExit `protobuf:"bytes,2,opt,name=exit,oneof"`
}

func (*FollowRequest_Output) isFollowRequest_Data() {}
func (*FollowRequest_Exit) isFollowRequest_Data()   {}

func (m *FollowRequest) GetData() isFollowRequest_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *FollowRequest) GetOutput() *CommandOutput {
	if x, ok := m.GetData().(*FollowRequest_Output); ok {
		return x.Output
	}
	return nil
}

func (m *FollowRequest) GetExit() *CommandExit {
	if x, ok := m.GetData().(*FollowRequest_Exit); ok {
		return x.Exit
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FollowRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FollowRequest_OneofMarshaler, _FollowRequest_OneofUnmarshaler, _FollowRequest_OneofSizer, []interface{}{
		(*FollowRequest_Output)(nil),
		(*FollowRequest_Exit)(nil),
	}
}

func _FollowRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FollowRequest)
	// data
	switch x := m.Data.(type) {
	case *FollowRequest_Output:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Output); err != nil {
			return err
		}
	case *FollowRequest_Exit:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Exit); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FollowRequest.Data has unexpected type %T", x)
	}
	return nil
}

func _FollowRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FollowRequest)
	switch tag {
	case 1: // data.output
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandOutput)
		err := b.DecodeMessage(msg)
		m.Data = &FollowRequest_Output{msg}
		return true, err
	case 2: // data.exit
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandExit)
		err := b.DecodeMessage(msg)
		m.Data = &FollowRequest_Exit{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FollowRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FollowRequest)
	// data
	switch x := m.Data.(type) {
	case *FollowRequest_Output:
		s := proto.Size(x.Output)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FollowRequest_Exit:
		s := proto.Size(x.Exit)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type FollowResponse struct {
	Command *Command `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
}

func (m *FollowResponse) Reset()                    { *m = FollowResponse{} }
func (m *FollowResponse) String() string            { return proto.CompactTextString(m) }
func (*FollowResponse) ProtoMessage()               {}
func (*FollowResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *FollowResponse) GetCommand() *Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func init() {
	proto.RegisterType((*Ping)(nil), "shell.Ping")
	proto.RegisterType((*Command)(nil), "shell.Command")
	proto.RegisterType((*CommandOutput)(nil), "shell.CommandOutput")
	proto.RegisterType((*CommandExit)(nil), "shell.CommandExit")
	proto.RegisterType((*TimeRequest)(nil), "shell.TimeRequest")
	proto.RegisterType((*TimeResponse)(nil), "shell.TimeResponse")
	proto.RegisterType((*PingRequest)(nil), "shell.PingRequest")
	proto.RegisterType((*PingResponse)(nil), "shell.PingResponse")
	proto.RegisterType((*ExecRequest)(nil), "shell.ExecRequest")
	proto.RegisterType((*ExecResponse)(nil), "shell.ExecResponse")
	proto.RegisterType((*FollowRequest)(nil), "shell.FollowRequest")
	proto.RegisterType((*FollowResponse)(nil), "shell.FollowResponse")
	proto.RegisterEnum("shell.CommandOutput_Source", CommandOutput_Source_name, CommandOutput_Source_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Shell service

type ShellClient interface {
	Time(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*TimeResponse, error)
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (Shell_ExecClient, error)
	Follow(ctx context.Context, opts ...grpc.CallOption) (Shell_FollowClient, error)
}

type shellClient struct {
	cc *grpc.ClientConn
}

func NewShellClient(cc *grpc.ClientConn) ShellClient {
	return &shellClient{cc}
}

func (c *shellClient) Time(ctx context.Context, in *TimeRequest, opts ...grpc.CallOption) (*TimeResponse, error) {
	out := new(TimeResponse)
	err := grpc.Invoke(ctx, "/shell.Shell/Time", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shellClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	out := new(PingResponse)
	err := grpc.Invoke(ctx, "/shell.Shell/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shellClient) Exec(ctx context.Context, in *ExecRequest, opts ...grpc.CallOption) (Shell_ExecClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Shell_serviceDesc.Streams[0], c.cc, "/shell.Shell/Exec", opts...)
	if err != nil {
		return nil, err
	}
	x := &shellExecClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Shell_ExecClient interface {
	Recv() (*ExecResponse, error)
	grpc.ClientStream
}

type shellExecClient struct {
	grpc.ClientStream
}

func (x *shellExecClient) Recv() (*ExecResponse, error) {
	m := new(ExecResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *shellClient) Follow(ctx context.Context, opts ...grpc.CallOption) (Shell_FollowClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Shell_serviceDesc.Streams[1], c.cc, "/shell.Shell/Follow", opts...)
	if err != nil {
		return nil, err
	}
	x := &shellFollowClient{stream}
	return x, nil
}

type Shell_FollowClient interface {
	Send(*FollowRequest) error
	Recv() (*FollowResponse, error)
	grpc.ClientStream
}

type shellFollowClient struct {
	grpc.ClientStream
}

func (x *shellFollowClient) Send(m *FollowRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *shellFollowClient) Recv() (*FollowResponse, error) {
	m := new(FollowResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Shell service

type ShellServer interface {
	Time(context.Context, *TimeRequest) (*TimeResponse, error)
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	Exec(*ExecRequest, Shell_ExecServer) error
	Follow(Shell_FollowServer) error
}

func RegisterShellServer(s *grpc.Server, srv ShellServer) {
	s.RegisterService(&_Shell_serviceDesc, srv)
}

func _Shell_Time_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShellServer).Time(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/shell.Shell/Time",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShellServer).Time(ctx, req.(*TimeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Shell_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShellServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/shell.Shell/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShellServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Shell_Exec_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ExecRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShellServer).Exec(m, &shellExecServer{stream})
}

type Shell_ExecServer interface {
	Send(*ExecResponse) error
	grpc.ServerStream
}

type shellExecServer struct {
	grpc.ServerStream
}

func (x *shellExecServer) Send(m *ExecResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Shell_Follow_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ShellServer).Follow(&shellFollowServer{stream})
}

type Shell_FollowServer interface {
	Send(*FollowResponse) error
	Recv() (*FollowRequest, error)
	grpc.ServerStream
}

type shellFollowServer struct {
	grpc.ServerStream
}

func (x *shellFollowServer) Send(m *FollowResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *shellFollowServer) Recv() (*FollowRequest, error) {
	m := new(FollowRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Shell_serviceDesc = grpc.ServiceDesc{
	ServiceName: "shell.Shell",
	HandlerType: (*ShellServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Time",
			Handler:    _Shell_Time_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Shell_Ping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Exec",
			Handler:       _Shell_Exec_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Follow",
			Handler:       _Shell_Follow_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "shell.proto",
}

func init() { proto.RegisterFile("shell.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 537 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0x5d, 0x8b, 0xd3, 0x40,
	0x14, 0xcd, 0xb4, 0x69, 0xe2, 0xde, 0xb4, 0xa5, 0x8c, 0x0a, 0xb1, 0x22, 0x5b, 0xe6, 0x29, 0x0f,
	0x4b, 0xba, 0xb6, 0xa0, 0xa0, 0x22, 0xb8, 0x6e, 0x65, 0xf7, 0x41, 0x2b, 0xd3, 0xfa, 0xa2, 0x0f,
	0x92, 0x6d, 0xc6, 0x1a, 0x48, 0x32, 0xdd, 0x26, 0xc1, 0xfe, 0x07, 0x7f, 0xa4, 0x7f, 0xc1, 0x9f,
	0x20, 0xf3, 0x55, 0x92, 0x22, 0x58, 0x5f, 0xf6, 0xed, 0xce, 0xbd, 0xe7, 0xcc, 0xc9, 0x3d, 0x67,
	0x08, 0x78, 0xc5, 0x77, 0x96, 0xa6, 0xe1, 0x66, 0xcb, 0x4b, 0x8e, 0x3b, 0xf2, 0x30, 0x3c, 0x5d,
	0x73, 0xbe, 0x4e, 0xd9, 0x58, 0x36, 0x6f, 0xaa, 0x6f, 0xe3, 0x32, 0xc9, 0x58, 0x51, 0x46, 0xd9,
	0x46, 0xe1, 0xc8, 0x33, 0xb0, 0x3f, 0x26, 0xf9, 0x1a, 0x87, 0x60, 0x8b, 0x91, 0x8f, 0x46, 0x28,
	0xf0, 0x26, 0xc3, 0x50, 0xf1, 0x42, 0xc3, 0x0b, 0x97, 0x86, 0x47, 0x25, 0x8e, 0x7c, 0x01, 0xf7,
	0x2d, 0xcf, 0xb2, 0x28, 0x8f, 0x71, 0x1f, 0x5a, 0x49, 0x2c, 0x89, 0x27, 0xb4, 0x95, 0xc4, 0x18,
	0x83, 0x9d, 0x47, 0x19, 0xf3, 0x5b, 0xb2, 0x23, 0x6b, 0xd1, 0x8b, 0xb6, 0xeb, 0xc2, 0x6f, 0x8f,
	0xda, 0xa2, 0x27, 0x6a, 0xec, 0x83, 0x2b, 0xae, 0xe2, 0x55, 0xe9, 0xdb, 0x23, 0x14, 0xb4, 0xa9,
	0x39, 0x92, 0xdf, 0x08, 0x7a, 0xfa, 0xf6, 0x79, 0x55, 0x6e, 0xaa, 0x12, 0x3f, 0x01, 0x58, 0xa9,
	0xc6, 0xd7, 0xbd, 0xd6, 0x89, 0xee, 0x5c, 0xc7, 0xf8, 0x11, 0xdc, 0x93, 0xfb, 0x8a, 0xa1, 0x92,
	0x75, 0xe5, 0xf9, 0x3a, 0xde, 0x2f, 0xd6, 0x3e, 0x6e, 0x31, 0x3c, 0x05, 0xa7, 0xe0, 0xd5, 0x76,
	0xc5, 0xe4, 0x47, 0xf5, 0x27, 0x8f, 0x43, 0x65, 0x6b, 0xe3, 0x7b, 0xc2, 0x85, 0x84, 0x50, 0x0d,
	0x15, 0xeb, 0xa5, 0x49, 0xce, 0xfc, 0x8e, 0x5a, 0x59, 0xd4, 0xe4, 0x0c, 0x1c, 0x85, 0xc2, 0x00,
	0xce, 0xe5, 0x9b, 0xd9, 0xfb, 0xf9, 0x87, 0x81, 0x25, 0xea, 0xc5, 0xf2, 0x72, 0xfe, 0x69, 0x39,
	0x40, 0xba, 0x9e, 0x51, 0x3a, 0x68, 0x91, 0x9f, 0x08, 0x3c, 0x2d, 0x31, 0xdb, 0x25, 0x77, 0xb9,
	0x30, 0x06, 0x7b, 0xc5, 0x63, 0xa6, 0x33, 0x90, 0x35, 0xe9, 0x81, 0x27, 0x60, 0x94, 0xdd, 0x56,
	0xac, 0x28, 0xc9, 0x6b, 0xe8, 0xaa, 0x63, 0xb1, 0xe1, 0x79, 0xc1, 0xfe, 0xfb, 0xb1, 0x84, 0xe0,
	0x89, 0x47, 0xa6, 0xaf, 0xc3, 0xa7, 0x60, 0xc7, 0x51, 0x19, 0x69, 0xba, 0xa7, 0x0d, 0x96, 0x08,
	0x39, 0x20, 0x63, 0xe8, 0x2a, 0xbc, 0xd6, 0xfb, 0x27, 0xe1, 0x39, 0x78, 0xb3, 0x1d, 0x5b, 0x19,
	0x81, 0x00, 0x5c, 0x6d, 0x95, 0xa6, 0xf4, 0x9b, 0x21, 0x52, 0x33, 0x26, 0xaf, 0xa0, 0xab, 0x88,
	0x5a, 0xe9, 0x0c, 0x1c, 0x2e, 0x13, 0xd6, 0xc4, 0x07, 0x7f, 0x4b, 0x9f, 0x6a, 0x0c, 0xb9, 0x85,
	0xde, 0x3b, 0x9e, 0xa6, 0xfc, 0x87, 0x11, 0x0e, 0x8f, 0xa1, 0x5f, 0x59, 0xe6, 0x02, 0x1c, 0x80,
	0xcd, 0x76, 0x49, 0x29, 0x23, 0xf4, 0x26, 0xb8, 0x89, 0x16, 0xef, 0xe0, 0xca, 0xa2, 0x12, 0x71,
	0xe1, 0x28, 0x0b, 0xc8, 0x0b, 0xe8, 0x1b, 0x49, 0xfd, 0xc9, 0x47, 0x2f, 0x3b, 0xf9, 0x85, 0xa0,
	0xb3, 0x10, 0x23, 0xfc, 0x14, 0xec, 0xa5, 0xcc, 0x5e, 0x43, 0x6b, 0x61, 0x0f, 0xef, 0x37, 0x7a,
	0x4a, 0x84, 0x58, 0x82, 0x22, 0x7f, 0x14, 0xb8, 0xee, 0xfe, 0x01, 0xa5, 0x1e, 0x1a, 0xb1, 0xf0,
	0x14, 0x6c, 0x61, 0xee, 0x9e, 0x52, 0x8b, 0x68, 0x4f, 0xa9, 0xbb, 0x4f, 0xac, 0x73, 0x84, 0x5f,
	0x82, 0xa3, 0x16, 0xc4, 0xc6, 0xbc, 0x86, 0xc5, 0xc3, 0x87, 0x07, 0x5d, 0x43, 0x0d, 0xd0, 0x39,
	0xba, 0x70, 0x3f, 0xab, 0xff, 0xde, 0x8d, 0x23, 0xdf, 0xe2, 0xf4, 0x4f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x88, 0x61, 0xf6, 0xb1, 0x14, 0x05, 0x00, 0x00,
}
